function fields = emit_change_function(headerPath, structName, outCPath, routineName, opts)
%EMIT_CHANGE_FUNCTION  Generate a typed "copy-if-changed" C function for a flat struct.
%
% fields = emit_change_function(headerPath, structName, outCPath, routineName, opts)
%
% INPUTS
%   headerPath   : path to the .h file
%   structName   : target struct name (typedef name or tag)
%   outCPath     : path to output .c
%   routineName  : e.g., 'copy_changes_kuku'
%   opts         : struct with fields (all optional)
%       .arrayFieldMode : 'elementwise' | 'whole-field-if-any'  (default 'elementwise')
%       .maxArrayDims   : 2  (supports 1D/2D fixed-size arrays in fields)
%
% OUTPUT
%   fields : cellstr of emitted field names (order as in header)
%
% NOTES
%   - Flat structs only (no nested structs/unions in the targeted struct).
%   - Removes // and /* */ comments (preserves string/char literals).
%   - Compares/assigns with typed code (no memcmp/memcpy).
%   - Bitfields => direct compare/assign.
%   - Pointers => pointer value compare/assign (not dereferenced).
%
% EXAMPLE
%   % header: typedef struct { float a; int b; } kuku;
%   emit_change_function('kuku.h','kuku','copy_kuku.c','copy_changes_kuku', struct('arrayFieldMode','elementwise'));

if nargin < 5 || isempty(opts), opts = struct; end
if ~isfield(opts,'arrayFieldMode') || isempty(opts.arrayFieldMode), opts.arrayFieldMode = 'elementwise'; end
if ~isfield(opts,'maxArrayDims')   || isempty(opts.maxArrayDims),   opts.maxArrayDims   = 2; end

txt = fileread(headerPath);
txt = strip_comments_preserve_strings(txt);

[body, ctype] = find_struct_block(txt, structName);
if isempty(body)
    error('Struct "%s" not found in %s.', structName, headerPath);
end

decls = split_top_level(body, ';');
fields = {};
D = []; % struct array of field info

for i = 1:numel(decls)
    d = strtrim(decls{i});
    if isempty(d), continue; end
    if startsWith(d,'typedef') || contains(d,'{') || contains(d,'}')
        continue; % skip nested/typedef junk
    end
    % split declarators by comma at top level
    parts = split_top_level(d, ',');
    if isempty(parts), continue; end

    % infer type part from first declarator
    [~, baseName] = last_ident(parts{1});
    typePart = strtrim(extractBefore(d, regexp(d, ['\<' baseName '\>'], 'once')));
    if isempty(typePart), typePart = ''; end

    for k = 1:numel(parts)
        tok = strtrim(parts{k});
        if isempty(tok), continue; end
        if contains(tok,'(') && contains(tok,')'), continue; end % function ptrs â€“ skip

        fi = struct('name','','isArray',false,'dims',[],'isBit',false,'raw',tok); %#ok<NASGU>
        % bitfield?
        if contains(tok,':')
            m = regexp(tok, '([A-Za-z_]\w*)\s*:\s*\d+', 'tokens', 'once');
            if isempty(m), continue; end
            name = m{1};
            fi.name   = name;
            fi.isBit  = true;
            fi.isArray= false;
            fi.dims   = [];
        else
            [name, dims] = parse_name_and_dims(tok, opts.maxArrayDims);
            if isempty(name), continue; end
            fi.name   = name;
            fi.isBit  = false;
            fi.isArray= ~isempty(dims);
            fi.dims   = dims;
        end

        fields{end+1} = fi.name; %#ok<AGROW>
        D = [D; fi]; %#ok<AGROW>
    end
end

% Emit C
[fdir, fname] = fileparts(headerPath); %#ok<ASGLU>
fid = fopen(outCPath,'w'); assert(fid>0,'Cannot open %s', outCPath);
c = onCleanup(@() fclose(fid));

fprintf(fid, "/* Auto-generated by emit_change_function. Do not edit. */\n");
%fprintf(fid, "#include <stddef.h>\n#include <stdint.h>\n");
%fprintf(fid, "#include \"%s.h\"\n\n", fname);

fprintf(fid, "/* Returns 1 if any field updated, else 0 */\n");
fprintf(fid, "short  %s(const %s* k1, const %s* k2, %s* k3)\n{\n", routineName, ctype, ctype, ctype);
fprintf(fid, "    short changed = 0;\n");

for i = 1:numel(D)
    nm = D(i).name;
    if D(i).isBit
        fprintf(fid, "    if (k1->%s != k2->%s) { k3->%s = k2->%s; changed = 1; }\n", nm,nm,nm,nm);
        continue;
    end
    if ~D(i).isArray
        fprintf(fid, "    if (k1->%s != k2->%s) { k3->%s = k2->%s; changed = 1; }\n", nm,nm,nm,nm);
    else
        dims = D(i).dims;
        if strcmpi(opts.arrayFieldMode,'whole-field-if-any')
            emit_array_any_then_full(fid, nm, dims);
        else
            emit_array_elementwise(fid, nm, dims);
        end
    end
end

fprintf(fid, "    return changed;\n}\n");
end

%======================== Helpers ========================%

function s = strip_comments_preserve_strings(s)
IN_CODE=0; IN_DQ=1; IN_SQ=2; IN_SL=3; IN_ML=4;
st=IN_CODE; out=char(zeros(1,numel(s))); j=0; i=1; n=numel(s);
while i<=n
    c=s(i);
    switch st
        case IN_CODE
            if c=='"', st=IN_DQ; j=j+1; out(j)=c; i=i+1;
            elseif c=='''', st=IN_SQ; j=j+1; out(j)=c; i=i+1;
            elseif c=='/' && i<n && s(i+1)=='/', st=IN_SL; i=i+2;
            elseif c=='/' && i<n && s(i+1)=='*', st=IN_ML; i=i+2;
            else, j=j+1; out(j)=c; i=i+1;
            end
        case IN_DQ
            j=j+1; out(j)=c; i=i+1;
            if c=='\' && i<=n, j=j+1; out(j)=s(i); i=i+1; % escape
            elseif c=='"', st=IN_CODE; end
        case IN_SQ
            j=j+1; out(j)=c; i=i+1;
            if c=='\' && i<=n, j=j+1; out(j)=s(i); i=i+1;
            elseif c=='''', st=IN_CODE; end
        case IN_SL
            if c==newline || c==char(13), st=IN_CODE; j=j+1; out(j)=c; end
            i=i+1;
        case IN_ML
            if c=='*' && i<n && s(i+1)=='/', st=IN_CODE; i=i+2; else, i=i+1; end
    end
end
s=out(1:j);
end

function [body, ctype] = find_struct_block(txt, want)
body=''; ctype='';
% typedef struct [tag]? { ... } TypeName;
% Search typedefs for the one we want
pat = 'typedef\s+struct\s*(\w+)?\s*\{';
starts = regexp(txt, pat, 'start');
for k=1:numel(starts)
    [~,e,~,~,caps] = regexp(txt(starts(k):end), pat, 'once');
    open = starts(k)+e-1;
    [blk, closeIdx] = grab_block(txt, open);
    if closeIdx==0, continue; end
    tail = txt(closeIdx+1 : min(closeIdx+200, numel(txt)));
    m = regexp(tail, '([A-Za-z_]\w*)\s*;', 'tokens', 'once');
    tn = ''; if ~isempty(m), tn=m{1}; end
    tag = caps{1};
    if strcmp(tn,want) || strcmp(tag,want)
        %  Hurray we found it
        body = blk;
        if (strcmp(tn,want) )
            ctype = string(tn) ; 
        else
            ctype = "struct "+want ; 
        end 

        ctype = char(ctype);
        return
    end
end
% struct Tag { ... };
m = regexp(txt, ['struct\s+' want '\s*\{'], 'start');
if ~isempty(m)
    bracePos = regexp(txt(m(1):end), '\{', 'once', 'start') + m(1) - 1;
    [blk, closeIdx] = grab_block(txt, bracePos);
    if closeIdx~=0, body=blk; ctype=['struct ' want]; end
end
end

function [blk, closeIdx] = grab_block(s, openIdx)
lvl=0; closeIdx=0;
for i=openIdx:numel(s)
    c=s(i);
    if c=='{', lvl=lvl+1; end
    if c=='}'
        lvl=lvl-1;
        if lvl==0, closeIdx=i; break; end
    end
end
if closeIdx==0, blk=''; else, blk=s(openIdx+1:closeIdx-1); end
end

function parts = split_top_level(s, delim)
parts={}; levP=0; levB=0; levC=0; start=1;
for i=1:numel(s)
    ch=s(i);
    switch ch
        case '('; levP=levP+1;
        case ')'; levP=max(0,levP-1);
        case '['; levB=levB+1;
        case ']'; levB=max(0,levB-1);
        case '{'; levC=levC+1;
        case '}'; levC=max(0,levC-1);
    end
    if ch==delim && levP==0 && levB==0 && levC==0
        parts{end+1}=strtrim(s(start:i-1)); %#ok<AGROW>
        start=i+1;
    end
end
parts{end+1}=strtrim(s(start:end));
end

function [name, dims] = parse_name_and_dims(tok, maxDims)
name=''; dims=[];
% last identifier is the name
ids = regexp(tok,'([A-Za-z_]\w*)','tokens');
if isempty(ids), return; end
name = ids{end}{1};
% fixed-size dimensions
br = regexp(tok, '\[(\d+)\]', 'tokens');
if ~isempty(br)
    dims = cellfun(@(c) str2double(c{1}), br);
    dims = dims(:).';
    if numel(dims) > maxDims, dims = dims(1:maxDims); end
end
end

function [lastId, full] = last_ident(tok)
ids = regexp(tok,'([A-Za-z_]\w*)','tokens');
if isempty(ids), lastId=''; full=''; else, lastId=ids{end}{1}; full=lastId; end
end

function emit_array_elementwise(fid, fld, dims)
nd = numel(dims);
idx = arrayfun(@(i) sprintf('i%d',i-1), 1:nd, 'uni', false);
for d=1:nd
    fprintf(fid, "    for (size_t %s = 0; %s < %u; %s++) {\n", idx{d}, idx{d}, dims(d), idx{d});
end
sub = sprintf('%s%s', fld, sprintf('[%s]', idx{:}));
fprintf(fid, "        if (k1->%s != k2->%s) { k3->%s = k2->%s; changed = 1; }\n", sub, sub, sub, sub);
for d=nd:-1:1
    fprintf(fid, "    }\n");
end
end

function emit_array_any_then_full(fid, fld, dims)
nd = numel(dims);
idx = arrayfun(@(i) sprintf('i%d',i-1), 1:nd, 'uni', false);

% diff pass
fprintf(fid, "    int __diff_%s = 0;\n", fld);
for d=1:nd
    fprintf(fid, "    for (size_t %s = 0; %s < %u; %s++) {\n", idx{d}, idx{d}, dims(d), idx{d});
end
sub = sprintf('%s%s', fld, sprintf('[%s]', idx{:}));
fprintf(fid, "        if (k1->%s != k2->%s) { __diff_%s = 1; break; }\n", sub, sub, fld);
% for d=nd:-1:1
%     fprintf(fid, "        if (__diff_%s) break;\n", fld);
%     fprintf(fid, "    }\n");
% end

% full copy pass (typed)
for d=1:nd
    fprintf(fid, "    if (__diff_%s) for (size_t %s = 0; %s < %u; %s++) {\n", fld, idx{d}, idx{d}, dims(d), idx{d});
end
fprintf(fid, "        k3->%s = k2->%s;\n", sub, sub);
for d=nd:-1:1
    fprintf(fid, "    }\n");
end
fprintf(fid, "    if (__diff_%s) changed = 1;\n", fld);
end
